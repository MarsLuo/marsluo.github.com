---
layout: post  
title:  "从 Git Hook 说开去"  
date:   2021-09-12 11:16:48
comments: ture
categories: Notes  
tags: [git]  
---

git commit --no-verify

Local hooks affect only the repository in which they reside. As you read through this section, remember that each developer can alter their own local hooks, so you can’t use them as a way to enforce a commit policy. They can, however, make it much easier for developers to adhere to certain guidelines.

介绍生命周期

介绍每个Hooks的 触发机制，传递参数等。

介绍每个阶段可以做哪些事情。

介绍服务端强制回退的例子。

介绍server hooks.

https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks

https://git-scm.com/book/en/v2/Customizing-Git-An-Example-Git-Enforced-Policy#_an_example_git_enforced_policy

## 一、初识 Git Hook
## 二、git hook 的分类
## 三、git hook 的使用场景
## 四、Git hook 的版本化
## 五、其他问题



-----------------------------------------------------------------------------------------------------

最近我在一个咨询项目上，为了帮助客户规范代码提交信息，我们决定建议客户使用 `git hooks`来实现。

为此，我们大概了解了一下 Git Hooks的相关知识。

## 一、初识 Git Hooks

Git Hooks 是什么？

```
Git Hooks 是一系列脚本， Git 允许 Git 仓库在触发某些事件时，去执行这些脚本。 我们可以通过 Git Hooks 在开发生命周期的关键节点，触发自定义的操作。
```

这里的脚本可以是任何正确命名的可执行脚本。由此可见，Git Hooks 的灵活性还是很强的。

在一个 Git 仓库中，我们可以在`.git/hooks`中发现一系列的文件：

```
applypatch-msg.sample     pre-push.sample
commit-msg.sample         pre-rebase.sample
fsmonitor-watchman.sample pre-receive.sample
post-update.sample        prepare-commit-msg.sample
pre-applypatch.sample     update.sample
pre-commit.sample
```

这些文件都是不同的 Git Hooks 脚本， 当然，他们现在并不会执行。

Git 能识别的文件名是不带`sample`的，所以当我们把上述文件的`sample`后缀去掉时，这些脚本才是有效的。

另外，因为上述文件都是可执行的脚本，所以在执行时，要注意给与其相应的权限。

## 二、Git Hooks的版本化

我们在上面看到 Git Hooks 的相关脚本存放在 `.git` 目录下。众所周知，`.git` 目录并不会纳入版本管理之中。 

但是对于团队来说，保证其可版本化是非常重要的功能，否则配置新脚本，或者对已有的脚本进行变化，都是一项浩大的工程。

经过简单的调研发现，无论是Java相关的技术栈，还是JS相关的技术栈，都有比较成熟的方案。

Java 相关的技术栈，比如 Spring 项目，Android项目等，可以使用Gradle的相关配置功能，将配置脚本纳入版本管理中，在`gradle build`时，再拷贝到 `.git\hooks`  目录中。 具体实现步骤，大家可以参见腾云的这个[项目]( https://github.com/e-commerce-sample/ecommerce-order-service)。

Js 相关的技术栈，可以使用 `husky` 来完成对应的配置。他依赖Npm的安装和配置，具体的使用方式可以参见他的[项目主页](https://github.com/typicode/husky)。

以上两种方式，都需要依靠特定的依赖管理工具才能完成。那依赖管理工具不支持，或者没有依赖管理工具，还想完成版本化管理 Git hooks， 怎么办呢？ 

Git hooks 的脚本文件都存放在`.git\hooks`目录下，但是该目录并不能被纳入版本管理中。经过查阅 `git` 的文档可知， 在17年 Git 提供了一项配置： `core.hooksPath`，通过它，可以将指定某个目录存放 git hook 的相关脚本。同时，该目录也可以纳入版本管理。

执行命令如下：

`git config --add core.hookspath .mygithooks`

执行该命令后，在提交时，会自动触发`.mygithooks` 目录下的脚本。

## 三、Git Hooks 的分类

Git Hooks 分两种，客户端钩子 、服务端钩子。 客户端钩子会被 commit，merge，rebase 等操作触发，而服务端会被push等操作触发。

### 1. 客户端钩子

客户端钩子 分为三种，提交工作流，电子邮件流，和其他。我们这里只讨论提交工作流和其他部分。

在 Git Hooks 中，若脚本以 `exit 0`退出应用，则流程会继续进行。若脚本以非0值退出，则流程会中断不会继续进行。

下图是提交工作流钩子的生命周期：

![img](file:///Users/ydluo/Documents/Learn/marsluo.github.com/assets/images/2021/09-20-0-0.png?lastModify=1632121341)

`pre commit` 不带任何参数，可以通过git diff 的形式获取变更的代码。一般用来检查即将提交的代码是否有效，比如是否能通过编译，是否能通过测试等。

`prepare commit msg` 带三个参数， 当前提交信息的文件路径，当前的提交类型，以及提交的SHA-1校验。 一般用来做提交信息的格式化，合并，整理等。

`commit msg` 带一个参数，即当前提交信息的文件路径。 一般用来检查提交信息格式等。

`post commit` 不带任何参数。 一般用于提交后发送通知等。

其他工作流包括`pre-rebase`, `post-rewrite`, `post-merge`, `pre-push` 这些在我们日常开发过程中用的比较少， 这里就不做介绍了。

### 2. 服务端钩子

`pre-receive` 
